public class Graph
{
  private final int V;        // number of vertices
  private int E;              // number of edges
  private Bag<Integer>[] adj; // adjacency lists, Bag ADT algorithms 4th section 1.3

  // crate a V-vertex graph with no edges
  public Graph(int V)
  {
    this.V = V;
    this.E = 0;
    adj = (Bag<Integer>[]) new Bag[V]; // Create array of lists.
    for (int v = 0; v < V; v++) {      // Initialize all lists to empty
      adj[v] = new Bag<Integer>();
    }
  }

  // read a graph from input stream in
  public Graph(In in)
  {
    this(in.readInt()); // Read V and construct this graph.
    int E = in.readInt(); // Read E.
    for (int i = 0; i < E; i++) {
      // Add an edge.
      int v = in.readInt(); // Read a vertex
      int w = in.readInt(); // Read another vertex
      addEdge(v, w); // Add edge connecting them.
    }
  }

  // number of vertices
  int V()
  {
    return V;
  }

  // number of edges
  int E() {
    return E;
  }

  // add edge v-w to this graph
  void addEdge(int v, int w) {
    adj[v].add(w);
    adj[w].add(v);
    E++;
  }

  // vertices adjacent to v
  Interable<Integer> adj(int v) {
    return adj[v];
  }

  // string representation
  String toString() {
    String s = V + " vertices, " + E + " edges\n";
    for (int v = 0; v < V; v++) {
      s += v + ": ";
      for (int w: this.adj(v)) {
        s += w + " ";
      }
      s += "\n";
    }
    return s;
  }

  // compute the degree of v
  public static int degree(Graph G, int v)
  {
    int degree = 0;
    for (int w: G.adj(v)) degree++;
    return degree;
  }

  // compute maximum degree
  public static int maxDegree(Graph G)
  {
    int max = 0;
    for (int v = 0; v < G.V(); v++) {
      if (degree(G, V) > max) {
        max = degree(G, v);
      }
    }
    return max;
  }

  // compute average degree
  public static int avgDegree(Graph G)
  {
    return 2 * G.E() / G.V();
  }

  // count self-loops
  public static int numberOfSelfLoops(Graph G)
  {
    int count = 0;
    for (int v = 0; v < G.V(); v++) {
      for (int w: G.adj(v)) {
        if (v == w) {
          count++;
        }
      }
    }
    return count / 2; // each edge counted twice
  }
}